<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ¬åœ°å›´æ£‹æ‰“è°±å·¥å…· (V0.4 iPadé«˜åº¦ä¿®æ­£ç‰ˆ)</title>
    <style>
        :root {
            --bg-color: #f4f4f4;
            --board-color: #DCB35C;
            --board-shadow: #8b6c42;
            --text-color: #333;
            --panel-bg: #fff;
            --accent-color: #4a90e2;
            --btn-hover: #357abd;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

        /* V1.4: ä¿®å¤ iPad 100vh é«˜åº¦ä¸ä¸€è‡´é—®é¢˜ï¼Œä½¿ç”¨ 100% */
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }

        header {
            height: 50px;
            background-color: var(--panel-bg);
            border-bottom:1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 10;
            flex-shrink: 0;
        }

        h1 { 
            font-size: 1rem; 
            font-weight: bold; 
            color: #2c3e50; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
        }
        h1 svg { margin-right: 8px; flex-shrink: 0; }

        .file-input-wrapper { 
            position: relative; 
            overflow: hidden; 
            display: inline-block; 
            flex-shrink: 0;
        }

        .btn-upload {
            background-color: #4a90e2;
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 5px rgba(74, 144, 226, 0.3);
            transition: all 0.2s ease;
        }
        
        .btn-upload:hover {
            background-color: var(--btn-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(74, 144, 226, 0.4);
        }

        input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* ä¸»ä½“å¸ƒå±€ */
        main {
            flex: 1;
            display: flex;
            /* V1.4: ç§»é™¤ fixed heightï¼Œä¾èµ– body 100% */
            min-height: 0; 
            padding: 10px;
            gap: 15px;
            overflow: hidden;
        }

        .board-container {
            flex: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e8e8e8;
            border-radius: 8px;
            padding: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            min-width: 0;
            /* V1.4: å…è®¸ flex æ”¶ç¼©ï¼Œé˜²æ­¢æº¢å‡º */
            min-height: 0; 
            flex-shrink: 1;
        }

        canvas {
            background-color: var(--board-color);
            box-shadow: 2px 2px 8px var(--board-shadow);
            border-radius: 2px;
        }

        /* å³ä¾§é¢æ¿ */
        .info-panel {
            flex: 1;
            min-width: 250px;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            overflow-x: hidden;
            /* V1.4: å…è®¸ flex æ”¶ç¼©ï¼Œé«˜åº¦å—é™æ—¶å¼ºåˆ¶æ»šåŠ¨ */
            min-height: 0;
            flex-shrink: 1;
        }

        .panel-section {
            background: var(--panel-bg);
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            /* é˜²æ­¢é¢æ¿è¶…å‡ºå¯è§†åŒºåŸŸ */
            min-height: 0;
        }

        .panel-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 0;
            border-bottom: 1px solid #eee;
            padding: 10px 12px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title:hover {
            background-color: #f9f9f9;
            color: #555;
        }

        .toggle-icon {
            font-size: 0.8rem;
            transition: transform 0.3s ease;
        }

        .panel-section.collapsed {
            flex: none !important;
            min-height: auto !important;
        }

        .panel-section.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .panel-content {
            padding: 12px;
            transition: opacity 0.3s ease;
        }

        .panel-section.collapsed .panel-content {
            display: none !important;
        }

        .game-info-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px 10px;
            font-size: 0.85rem;
        }

        .info-label { font-weight: 600; color: #555; text-align: right; }
        .info-value { color: #222; }

        .comment-box {
            min-height: 80px;
            font-size: 0.9rem;
            line-height: 1.4;
            color: #333;
            white-space: pre-wrap;
            background: #f9f9f9;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        /* æ§åˆ¶æŒ‰é’®åŒºåŸŸ */
        .controls {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            height: 50px;
        }

        .btn {
            background-color: var(--accent-color);
            color: white;
            padding: 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
            border: none;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .btn:hover { background-color: var(--btn-hover); }
        .btn-secondary { background-color: #e0e0e0; color: #333; }
        .btn-secondary:hover { background-color: #d0d0d0; }

        .branch-selector {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .branch-btn {
            font-size: 0.75rem;
            padding: 3px 6px;
            min-width: 25px;
            cursor: pointer;
        }
        .branch-btn.active {
            background-color: var(--accent-color);
            color: white;
        }

        .status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
        }
        .status-message.show { opacity: 1; }

        /* V1.4: å“åº”å¼é€‚é… - å½»åº•è§£å†³ iPad æ¨ªå±æº¢å‡ºå’Œç«–å±æ§åˆ¶æŒ‰é’®éšè—é—®é¢˜ */
        @media (max-width: 900px) {
            main {
                flex-direction: column;
                /* é«˜åº¦ç”± flex è‡ªåŠ¨åˆ†é…ï¼Œä¸å†ä½¿ç”¨ calc(100vh) */
                overflow: hidden; 
                padding: 10px;
            }

            .board-container {
                flex: 1;
                width: 100%;
                min-height: 200px;
                margin-bottom: 10px;
                /* ç¡®ä¿ canvas èƒ½è¢«å‹ç¼© */
                min-height: 0;
            }

            .info-panel {
                flex: 0 1 auto; /* é«˜åº¦ç”±å†…å®¹å†³å®š */
                width: 100%;
                max-width: 100%;
                
                /* V1.4 å…³é”®ä¿®å¤ï¼šé™åˆ¶æœ€å¤§é«˜åº¦ï¼Œä½¿ç”¨ç›¸å¯¹å•ä½é¿å… 100vh bug */
                max-height: 40vh; 
                overflow-y: auto;
                flex-shrink: 1; /* å¼ºåˆ¶æ”¶ç¼© */
            }

            /* è§£è¯´æ¡†å†…éƒ¨æ»šåŠ¨ */
            .comment-box {
                flex: none; 
                height: auto;
                max-height: 120px; /* é™åˆ¶é«˜åº¦ï¼Œé˜²æ­¢æ’‘å¤§é¢æ¿ */
                overflow-y: auto;
            }

            /* æ§åˆ¶é¢æ¿ç½®åº• */
            .info-panel .panel-section:last-child {
                margin-top: auto; 
                flex-shrink: 0; 
            }
        }
    </style>
</head>
<body>

<header>
    <h1>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 100" width="30" height="15">
            <defs>
                <radialGradient id="blackGradient" cx="0.5" cy="0.5" r="0.5" gradientUnits="objectBoundingBox">
                    <stop offset="0%" stop-color="#000000" />
                    <stop offset="100%" stop-color="#333333" />
                </radialGradient>
                <radialGradient id="whiteGradient" cx="0.5" cy="0.5" r="0.5" gradientUnits="objectBoundingBox">
                    <stop offset="0%" stop-color="#FFFFFF" />
                    <stop offset="100%" stop-color="#DDDDDD" />
                </radialGradient>
                <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur" />
                    <feOffset dx="2" dy="2" result="offsetBlur" />
                    <feMerge>
                        <feMergeNode in="offsetBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>
            <circle cx="70" cy="50" r="40" fill="url(#blackGradient)" filter="url(#shadow)" />
            <circle cx="130" cy="50" r="40" fill="url(#whiteGradient)" filter="url(#shadow)" />
        </svg>
        SGFå›´æ£‹æ‰“è°± V0.4
    </h1>
    <div class="file-input-wrapper">
        <button class="btn-upload">ğŸ“‚ æ‰“å¼€</button>
        <input type="file" id="fileInput" accept=".sgf,.SGF,.Sgf">
    </div>
</header>

<main>
    <div class="board-container" id="boardContainer">
        <canvas id="goBoard"></canvas>
    </div>

    <aside class="info-panel">
        <div class="panel-section">
            <div class="panel-title" onclick="togglePanel(this)">
                å¯¹å±€ä¿¡æ¯ <span class="toggle-icon">â–¼</span>
            </div>
            <div class="panel-content">
                <div class="game-info-grid">
                    <span class="info-label">è·¯æ•°:</span>
                    <span class="info-value" id="infoSize">-</span>
					                <span class="info-label">æ¯”èµ›:</span>
                <span class="info-value" id="infoEvent">-</span>
                    <span class="info-label">é»‘æ–¹:</span>
                    <span class="info-value" id="infoBlack">-</span>
                    <span class="info-label">ç™½æ–¹:</span>
                    <span class="info-value" id="infoWhite">-</span>
                    <span class="info-label">ç»“æœ:</span>
                    <span class="info-value" id="infoResult">-</span>
                    <span class="info-label">æ‰‹æ•°:</span>
                    <span class="info-value" id="infoMove">-</span>
                </div>
            </div>
        </div>

        <div class="panel-section" style="min-height: 100px;">
            <div class="panel-title" onclick="togglePanel(this)">
                å½“å‰è§£è¯´ <span class="toggle-icon">â–¼</span>
            </div>
            <div class="panel-content">
                <div class="comment-box" id="moveComment">ç­‰å¾…åŠ è½½æ£‹è°±...</div>
                <div id="branchContainer" style="display:none;">
                    <div class="branch-selector" id="branchButtons"></div>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-title" style="cursor: default;">æ§åˆ¶</div>
            <div class="panel-content" style="padding-bottom: 12px;">
                <div class="controls">
                    <button class="btn btn-secondary" id="btnFirst" title="ç¬¬ä¸€æ‰‹">|&lt;</button>
                    <button class="btn btn-secondary" id="btnPrev" title="å‰ä¸€æ‰‹">&lt;</button>
                    <button class="btn btn-secondary" id="btnNext" title="åä¸€æ­¥">&gt;</button>
                    <button class="btn btn-secondary" id="btnLast" title="æœ€åä¸€æ‰‹">&gt;|</button>
                    <button class="btn btn-secondary" id="btnJudge" title="å½¢åŠ¿åˆ¤æ–­" style="background-color: #e67e22;">âš–ï¸</button>
                    <button class="btn btn-secondary" id="btnDeleteStone" title="åˆ é™¤æ­»å­">ğŸ—‘ï¸</button>
                </div>
            </div>
        </div>
    </aside>
</main>

<div id="statusMsg" class="status-message"></div>

<!-- åˆ†æ”¯å˜åŒ–å›¾è§£æ¨¡æ€æ¡† -->
<div id="branchModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; justify-content: center; align-items: center;">
    <div style="background: white; padding: 15px; border-radius: 8px; max-width: 95%; width: 500px; max-height: 90vh; overflow-y: auto; box-shadow: 0 5px 20px rgba(0,0,0,0.5); text-align: center;">
        <h3 style="margin-bottom: 15px; color: #333; font-size: 1rem;" id="branchModalTitle">åˆ†æ”¯å˜åŒ–å›¾è§£</h3>
        <div id="branchPreviews" style="display: flex; justify-content: center; margin-bottom: 15px; background: #eee; padding: 10px; border-radius: 4px;">
            <!-- åŠ¨æ€ç”Ÿæˆ Canvas -->
        </div>
        <div style="display: flex; gap: 10px; justify-content: center; padding-top: 10px; border-top: 1px solid #eee;">
            <button class="btn" style="width: auto; padding: 0 20px;" onclick="window.app.switchFromModal()">åˆ‡æ¢</button>
            <button class="btn btn-secondary" style="width: auto; padding: 0 20px;" onclick="document.getElementById('branchModal').style.display='none'">å…³é—­</button>
        </div>
    </div>
</div>

<!-- å½¢åŠ¿åˆ¤æ–­æ¨¡æ€æ¡† -->
<div id="judgeModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 998; justify-content: center; align-items: center;">
    <div style="background: white; padding: 20px; border-radius: 8px; max-width: 90%; width: 350px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
        <h3 style="margin-bottom: 15px; color: #333;">ç›˜é¢å½¢åŠ¿åˆ†æ</h3>
        <div id="judgeContent" style="margin-bottom: 15px; font-size: 0.9rem; line-height: 1.5; color: #555;"></div>
        <button class="btn" style="width: 100%;" onclick="document.getElementById('judgeModal').style.display='none'">å…³é—­</button>
    </div>
</div>

<script>
// é¢æ¿æŠ˜å åŠŸèƒ½
function togglePanel(titleElement) {
    const section = titleElement.parentElement;
    section.classList.toggle('collapsed');
}

class SGFParser {
    constructor() { this.text = ""; this.pos = 0; }
    parse(sgfText) {
        try {
            this.text = sgfText.replace(/[\t\r\n]/g, ''); this.pos = 0;
            if (!this.text.startsWith('(')) throw new Error("SGF æ ¼å¼æ— æ•ˆ");
            const virtualRoot = { properties: {}, parent: null, children: [] };
            this.parseTree(virtualRoot);
            if (virtualRoot.children.length > 0) return virtualRoot.children[0];
            throw new Error("æœªæ‰¾åˆ°ä»»ä½•æ£‹è°±èŠ‚ç‚¹");
        } catch (e) { console.error(e); throw e; }
    }
    parseTree(parentNode) {
        if (this.text[this.pos] !== '(') return; this.pos++; this.parseSequence(parentNode);
        if (this.text[this.pos] === ')') this.pos++;
    }
    parseSequence(parentNode) {
        let lastNode = parentNode;
        while (this.pos < this.text.length && this.text[this.pos] !== ')') {
            if (this.text[this.pos] === ';') {
                const node = this.parseNode();
                if (node) {
                    node.parent = lastNode;
                    lastNode.children.push(node);
                    lastNode = node;
                    while (this.pos < this.text.length && this.text[this.pos] === '(') this.parseTree(lastNode);
                }
            } else if (this.text[this.pos] === '(') {
                this.parseTree(parentNode);
            } else { this.pos++; }
        }
    }
    parseNode() {
        if (this.text[this.pos] !== ';') return null; this.pos++;
        const node = { properties: {}, parent: null, children: [] };
        while (this.pos < this.text.length) {
            const char = this.text[this.pos];
            if (char === ';' || char === '(' || char === ')') break;
            if (/[A-Z]/.test(char)) {
                let propName = "";
                while (this.pos < this.text.length && /[A-Z]/.test(this.text[this.pos])) propName += this.text[this.pos++];
                const values = [];
                while (this.pos < this.text.length && this.text[this.pos] === '[') {
                    const val = this.parseValue();
                    if (val !== null) values.push(val);
                }
                if (values.length > 0) node.properties[propName] = values;
            } else { this.pos++; }
        }
        return node;
    }
    parseValue() {
        if (this.text[this.pos] !== '[') return null; this.pos++;
        let val = "";
        while (this.pos < this.text.length && this.text[this.pos] !== ']') {
            if (this.text[this.pos] === '\\' && this.pos + 1 < this.text.length) { val += this.text[this.pos + 1]; this.pos += 2; } 
            else { val += this.text[this.pos++]; }
        }
        if (this.pos < this.text.length && this.text[this.pos] === ']') this.pos++;
        return val;
    }
}

class GoEngine {
    constructor(size = 19) {
        this.size = size;
        this.EMPTY = 0; this.BLACK = 1; this.WHITE = 2;
    }
    createBoard() {
        return Array.from({ length: this.size }, () => Array(this.size).fill(this.EMPTY));
    }
    getStone(board, x, y) {
        if (x < 0 || x >= this.size || y < 0 || y >= this.size) return -1;
        return board[y][x];
    }
    getGroup(board, x, y) {
        const color = board[y][x];
        if (color === this.EMPTY) return [];
        const group = []; const visited = new Set(); const queue = [{x, y}];
        visited.add(`${x},${y}`);
        while (queue.length > 0) {
            const curr = queue.pop(); group.push(curr);
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (let d of dirs) {
                const nx = curr.x + d[0]; const ny = curr.y + d[1];
                if (this.getStone(board, nx, ny) === color && !visited.has(`${nx},${ny}`)) { visited.add(`${nx},${ny}`); queue.push({x: nx, y: ny}); }
            }
        }
        return group;
    }
    countLiberties(board, group) {
        const liberties = new Set();
        for (let stone of group) {
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (let d of dirs) {
                const nx = stone.x + d[0]; const ny = stone.y + d[1];
                if (this.getStone(board, nx, ny) === this.EMPTY) liberties.add(`${nx},${ny}`);
            }
        }
        return liberties.size;
    }
    play(board, x, y, color) {
        const newBoard = board.map(row => [...row]);
        if (x < 0 || y < 0 || x >= this.size || y >= this.size) return { board: newBoard, captured: [] };
        newBoard[y][x] = color;
        const opponent = color === this.BLACK ? this.WHITE : this.BLACK;
        const capturedStones = []; const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (let d of dirs) {
            const nx = x + d[0]; const ny = y + d[1];
            if (this.getStone(newBoard, nx, ny) === opponent) {
                const group = this.getGroup(newBoard, nx, ny);
                if (this.countLiberties(newBoard, group) === 0) {
                    for (let s of group) { newBoard[s.y][s.x] = this.EMPTY; capturedStones.push(s); }
                }
            }
        }
        if (capturedStones.length === 0) {
            const myGroup = this.getGroup(newBoard, x, y);
            if (this.countLiberties(newBoard, myGroup) === 0) {
                for (let s of myGroup) { newBoard[s.y][s.x] = this.EMPTY; }
            }
        }
        return { board: newBoard, captured: capturedStones };
    }
}

class App {
    constructor() {
        this.canvas = document.getElementById('goBoard');
        this.ctx = this.canvas.getContext('2d');
        this.container = document.getElementById('boardContainer');
        
        this.parser = new SGFParser();
        this.engine = new GoEngine(19);
        
        this.rootNode = null;
        this.boardSize = 19;
        this.history = []; 
        this.boardState = null;
        this.territoryMap = null;
        this.isDeleteMode = false;
        this.tempBranchNode = null;

        this.bindEvents();
        this.reset();
        
        this.resizeObserver = new ResizeObserver(() => this.resizeCanvas());
        this.resizeObserver.observe(this.container);
        
        setTimeout(() => this.resizeCanvas(), 0);
    }

    reset() {
        this.rootNode = null;
        this.history = [];
        this.boardSize = 19;
        this.engine.size = 19;
        this.boardState = this.engine.createBoard();
        this.updateInfoPanel('-');
        this.drawBoard();
    }

    resizeCanvas() {
        const rect = this.container.getBoundingClientRect();
        const padding = 20;
        const availableWidth = rect.width - padding;
        const availableHeight = rect.height - padding;
        
        let size = Math.min(availableWidth, availableHeight);
        size = Math.max(200, Math.min(800, size)); 
        
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = size * dpr;
        this.canvas.height = size * dpr;
        this.canvas.style.width = `${size}px`;
        this.canvas.style.height = `${size}px`;
        
        const ctx = this.canvas.getContext('2d');
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        
        this.boardPixelSize = size;
        this.recalcGridSize();
        this.drawBoard();
    }

    recalcGridSize() {
        this.gridSize = this.boardPixelSize / (this.boardSize + 1); 
        this.padding = this.gridSize;
        this.stoneRadius = this.gridSize * 0.45;
    }

    bindEvents() {
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileLoad(e));
        document.getElementById('btnFirst').addEventListener('click', () => this.goToFirst());
        document.getElementById('btnLast').addEventListener('click', () => this.goToLast());
        document.getElementById('btnPrev').addEventListener('click', () => this.stepPrev());
        document.getElementById('btnNext').addEventListener('click', () => this.stepNext());
        document.getElementById('btnJudge').addEventListener('click', () => this.judgeStatus());
        document.getElementById('btnDeleteStone').addEventListener('click', () => this.toggleDeleteMode());
        this.canvas.addEventListener('mousedown', (e) => this.handleBoardClick(e));
        
        document.addEventListener('keydown', (e) => {
            if (['PageDown', 'PageUp', 'Home', 'End', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            if (e.key === 'PageDown' || e.key === 'ArrowDown' || e.key === 'ArrowRight') { this.stepNext(); } 
            else if (e.key === 'PageUp' || e.key === 'ArrowUp' || e.key === 'ArrowLeft') { this.stepPrev(); } 
            else if (e.key === 'Home') { this.goToFirst(); } 
            else if (e.key === 'End') { this.goToLast(); }
        });
    }

    handleFileLoad(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const buffer = e.target.result;
                let sgfText = null;
                try {
                    const decoderUtf8 = new TextDecoder('utf-8', { fatal: true });
                    sgfText = decoderUtf8.decode(buffer);
                } catch (utf8Error) {
                    try {
                        const decoderGbk = new TextDecoder('gbk');
                        sgfText = decoderGbk.decode(buffer);
                    } catch (gbkError) {
                        showToast("æ–‡ä»¶ç¼–ç æ— æ³•è¯†åˆ«");
                        return;
                    }
                }
                const root = this.parser.parse(sgfText);
                if (root) {
                    this.loadGame(root);
                    showToast("æ£‹è°±åŠ è½½æˆåŠŸ");
                } else {
                    throw new Error("è§£æè¿”å›ç©ºç»“æœ");
                }
            } catch (err) {
                console.error("åŠ è½½å¤±è´¥:", err);
                showToast("åŠ è½½å¤±è´¥: " + err.message);
                this.reset();
            }
            event.target.value = ''; 
        };
        reader.readAsArrayBuffer(file);
    }

    loadGame(root) {
        this.rootNode = root;
        this.history = [root]; 
        this.currentNode = root;
        this.goToLastSilent();

        const sz = root.properties['SZ'];
        if (sz) {
            const size = parseInt(sz[0]);
            if (!isNaN(size) && size > 0 && size < 26) {
                this.boardSize = size;
                this.engine.size = size;
                this.recalcGridSize();
            }
        }
        document.getElementById('infoSize').textContent = `${this.boardSize}è·¯`;
        this.updateGameInfo(this.currentNode);
        this.updateUI();
    }

    calculateBoardState(nodePath) {
        if (!nodePath || nodePath.length === 0) return this.engine.createBoard();
        let board = this.engine.createBoard();
        for (const node of nodePath) {
            const props = node.properties;
            if (props['AB']) props['AB'].forEach(coord => { const [x, y] = this.sgfToCoord(coord); if (x >= 0 && y >= 0) board[y][x] = this.engine.BLACK; });
            if (props['AW']) props['AW'].forEach(coord => { const [x, y] = this.sgfToCoord(coord); if (x >= 0 && y >= 0) board[y][x] = this.engine.WHITE; });
            if (props['B']) {
                const [x, y] = this.sgfToCoord(props['B'][0]);
                if (x >= 0 && y >= 0) { const res = this.engine.play(board, x, y, this.engine.BLACK); board = res.board; }
            } else if (props['W']) {
                const [x, y] = this.sgfToCoord(props['W'][0]);
                if (x >= 0 && y >= 0) { const res = this.engine.play(board, x, y, this.engine.WHITE); board = res.board; }
            }
        }
        return board;
    }

    recalculateBoard() {
        this.boardState = this.calculateBoardState(this.history);
    }

    updateUI() {
        this.recalculateBoard();
        this.drawBoard();
        const currentNode = this.history[this.history.length - 1];
        const comment = currentNode.properties['C'] ? currentNode.properties['C'][0] : '';
        document.getElementById('moveComment').textContent = comment || "æ­¤æ‰‹æ— è§£è¯´ã€‚";

        let moveCount = 0;
        for (let node of this.history) { if (node.properties['B'] || node.properties['W']) moveCount++; }
        document.getElementById('infoMove').textContent = moveCount > 0 ? `${moveCount} æ‰‹` : '-';

        const branchContainer = document.getElementById('branchContainer');
        const branchBtns = document.getElementById('branchButtons');
        branchBtns.innerHTML = '';
        
        if (currentNode.parent && currentNode.parent.children.length > 1) {
            branchContainer.style.display = 'block';
            currentNode.parent.children.forEach((sibling, index) => {
                const btn = document.createElement('button');
                btn.className = `btn btn-secondary branch-btn ${sibling === currentNode ? 'active' : ''}`;
                btn.textContent = sibling.properties['N'] ? sibling.properties['N'][0].substring(0,4) : `åˆ†æ”¯${index+1}`;
                btn.onclick = () => this.showBranchPreview(sibling, sibling.properties['N'] ? sibling.properties['N'][0] : `åˆ†æ”¯ ${index+1}`);
                branchBtns.appendChild(btn);
            });
        } else {
            branchContainer.style.display = 'none';
        }
    }

    buildPathToNode(targetNode) {
        if (!targetNode) return [];
        const path = [];
        let curr = targetNode;
        while(curr) { path.unshift(curr); curr = curr.parent; }
        return path;
    }

    jumpToNode(node) {
        if (!node) return;
        this.history = this.buildPathToNode(node);
        this.updateUI();
        document.getElementById('branchModal').style.display = 'none';
        showToast("å·²è·³è½¬è‡³é€‰å®šå˜åŒ–");
    }

    switchFromModal() {
        if (this.tempBranchNode) {
            this.jumpToNode(this.tempBranchNode);
            showToast("å·²åˆ‡æ¢åˆ°æ­¤å˜åŒ–");
        }
    }

    showBranchPreview(startNode, branchName) {
        this.tempBranchNode = startNode;
        const container = document.getElementById('branchPreviews');
        container.innerHTML = '';
        document.getElementById('branchModalTitle').textContent = `"${branchName}" å˜åŒ–`;

        const moves = [];
        let temp = startNode;
        let stepCount = 1;
        while(temp) {
            const props = temp.properties;
            let moveCoord = null;
            let color = null;
            if (props['B']) { moveCoord = this.sgfToCoord(props['B'][0]); color = 1; }
            else if (props['W']) { moveCoord = this.sgfToCoord(props['W'][0]); color = 2; }
            if (moveCoord && moveCoord[0] !== -1) {
                moves.push({x: moveCoord[0], y: moveCoord[1], color: color, step: stepCount});
                stepCount++;
            }
            temp = temp.children[0];
        }

        const cssSize = Math.min(400, window.innerWidth - 60); 
        const dpr = window.devicePixelRatio || 1;
        const canvas = document.createElement('canvas');
        canvas.width = cssSize * dpr;
        canvas.height = cssSize * dpr;
        canvas.style.width = `${cssSize}px`;
        canvas.style.height = `${cssSize}px`;
        
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        
        let lastNode = startNode;
        while(lastNode.children && lastNode.children.length > 0) lastNode = lastNode.children[0];
        const fullPath = this.buildPathToNode(lastNode);
        const finalBoardState = this.calculateBoardState(fullPath);
        
        this.drawNumberedBoardHighDef(ctx, cssSize, finalBoardState, moves);
        container.appendChild(canvas);
        document.getElementById('branchModal').style.display = 'flex';
    }

    drawNumberedBoardHighDef(ctx, size, boardState, moves) {
        const grid = size / (this.boardSize + 1);
        const pad = grid;
        ctx.clearRect(0, 0, size, size);
        
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, size, size);
        ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.beginPath();
        for(let i=0; i<this.boardSize; i++) {
            const pos = pad + i*grid;
            ctx.moveTo(pad, pos); ctx.lineTo(size-pad, pos);
            ctx.moveTo(pos, pad); ctx.lineTo(pos, size-pad);
        }
        ctx.stroke();

        const stars = [];
        if (this.boardSize === 19) stars.push(3, 9, 15);
        else if (this.boardSize === 13) stars.push(3, 6, 9);
        else if (this.boardSize === 9) stars.push(2, 4, 6);
        
        if (stars.length > 0) {
            ctx.fillStyle = '#000000';
            for (let r of stars) {
                for (let c of stars) {
                    ctx.beginPath(); ctx.arc(pad + c * grid, pad + r * grid, grid * 0.1, 0, Math.PI * 2); ctx.fill();
                }
            }
        }

        for(let y=0; y<this.boardSize; y++) {
            for(let x=0; x<this.boardSize; x++) {
                const color = boardState[y][x];
                if(color !== 0) {
                    const cx = pad + x*grid;
                    const cy = pad + y*grid;
                    const r = grid * 0.45;
                    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
                    if (color === 1) {
                        ctx.fillStyle = '#000000'; ctx.fill();
                    } else {
                        ctx.fillStyle = '#FFFFFF'; ctx.fill();
                        ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.stroke();
                    }
                }
            }
        }
        
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.font = `bold ${grid * 0.5}px Arial`;
        
        moves.forEach(m => {
            const cx = pad + m.x * grid;
            const cy = pad + m.y * grid;
            ctx.fillStyle = m.color === 1 ? '#FFFFFF' : '#000000';
            if (m.color === 2) {
                ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2;
                ctx.strokeText(m.step, cx, cy);
            }
            ctx.fillText(m.step, cx, cy);
        });
    }

    stepNext() {
        if (!this.currentNode) return;
        this.territoryMap = null;
        const current = this.history[this.history.length - 1];
        let next = null;
        if (current.children.length > 0) next = current.children[0];
        if (next) {
            this.history.push(next);
            this.updateUI();
        } else { showToast("å·²æ˜¯æœ€åä¸€æ‰‹"); }
    }

    stepPrev() {
        if (!this.currentNode) return;
        this.territoryMap = null;
        if (this.history.length > 1) {
            this.history.pop();
            this.updateUI();
        } else { showToast("å·²æ˜¯ç¬¬ä¸€æ‰‹"); }
    }

    goToFirst() {
        this.territoryMap = null;
        if (this.rootNode) {
            this.history = [this.rootNode];
            this.updateUI();
        }
    }

    goToLast() {
        this.territoryMap = null;
        if (this.history.length > 0) {
            let tempHistory = [...this.history];
            let node = tempHistory[tempHistory.length - 1];
            while (node.children && node.children.length > 0) {
                node = node.children[0];
                tempHistory.push(node);
            }
            this.history = tempHistory;
            this.updateUI();
        }
    }

    goToLastSilent() {
        let node = this.rootNode;
        this.history = [node];
        while (node.children && node.children.length > 0) {
            node = node.children[0];
            this.history.push(node);
        }
    }

    toggleDeleteMode() {
        this.isDeleteMode = !this.isDeleteMode;
        const btn = document.getElementById('btnDeleteStone');
        if (this.isDeleteMode) {
            btn.style.backgroundColor = '#e74c3c'; 
            btn.style.color = 'white'; 
            btn.textContent = 'âŒ'; 
            this.canvas.style.cursor = 'pointer'; 
            showToast("ç‚¹å‡»æ£‹å­åˆ é™¤");
        } else {
            btn.style.backgroundColor = ''; 
            btn.style.color = ''; 
            btn.textContent = 'ğŸ—‘ï¸'; 
            this.canvas.style.cursor = 'default'; 
            showToast("é€€å‡ºåˆ é™¤æ¨¡å¼");
        }
    }

    handleBoardClick(e) {
        if (!this.isDeleteMode || !this.boardState) return;
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left; const y = e.clientY - rect.top;
        const col = Math.round((x - this.padding) / this.gridSize);
        const row = Math.round((y - this.padding) / this.gridSize);
        if (col >= 0 && col < this.boardSize && row >= 0 && row < this.boardSize) {
            if (this.boardState[row][col] !== 0) {
                this.boardState[row][col] = 0;
                this.drawBoard();
            }
        }
    }

    updateInfoPanel(result) {
	        document.getElementById('infoEvent').textContent = '-';
        document.getElementById('infoBlack').textContent = '-';
        document.getElementById('infoWhite').textContent = '-';
        document.getElementById('infoResult').textContent = result;
        document.getElementById('moveComment').textContent = 'ç­‰å¾…åŠ è½½æ£‹è°±...';
        document.getElementById('infoMove').textContent = '-';
        document.getElementById('branchContainer').style.display = 'none';
    }
    
    updateGameInfo(node) {
        const props = node.properties;
        const getVal = (key) => props[key] ? props[key][0] : '-';
		document.getElementById('infoEvent').textContent = getVal('EV') || getVal('EVENT');
        document.getElementById('infoBlack').textContent = (getVal('PB') || getVal('BLACK')) + (getVal('BR') ? ` (${getVal('BR')})` : '');
        document.getElementById('infoWhite').textContent = (getVal('PW') || getVal('WHITE')) + (getVal('WR') ? ` (${getVal('WR')})` : '');
        document.getElementById('infoResult').textContent = getVal('RE') || getVal('RESULT');
    }

    sgfToCoord(s) {
        if (!s || s.length < 2) return [-1, -1];
        const x = s.charCodeAt(0) - 97;
        const sgfY = s.charCodeAt(1) - 97;
        const y = sgfY; 
        if (x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize) return [-1, -1];
        return [x, y];
    }

    judgeStatus() {
        if (!this.boardState) return;
        let blackStones = 0; let whiteStones = 0;
        const size = this.boardSize;
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if (this.boardState[y][x] === this.engine.BLACK) blackStones++;
                else if (this.boardState[y][x] === this.engine.WHITE) whiteStones++;
            }
        }
        const visited = new Set();
        let blackTerritory = 0; let whiteTerritory = 0;
        this.territoryMap = Array.from({ length: this.boardSize }, () => Array(this.boardSize).fill(0));
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if (this.boardState[y][x] === this.engine.EMPTY && !visited.has(`${x},${y}`)) {
                    const region = []; const queue = [{x, y}]; visited.add(`${x},${y}`);
                    let blackContacts = 0; let whiteContacts = 0;
                    while (queue.length > 0) {
                        const curr = queue.pop(); region.push(curr);
                        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                        for (let d of dirs) {
                            const nx = curr.x + d[0]; const ny = curr.y + d[1];
                            if (nx < 0 || nx >= size || ny < 0 || ny >= size) continue;
                            const color = this.boardState[ny][nx];
                            if (color === this.engine.EMPTY) {
                                if (!visited.has(`${nx},${ny}`)) { visited.add(`${nx},${ny}`); queue.push({x: nx, y: ny}); }
                            } else if (color === this.engine.BLACK) blackContacts++;
                            else if (color === this.engine.WHITE) whiteContacts++;
                        }
                    }
                    if (blackContacts > 0 && whiteContacts === 0) {
                        region.forEach(p => { this.territoryMap[p.y][p.x] = 1; }); blackTerritory += region.length;
                    } else if (whiteContacts > 0 && blackContacts === 0) {
                        region.forEach(p => { this.territoryMap[p.y][p.x] = 2; }); whiteTerritory += region.length;
                    } else if (blackContacts > 0 && whiteContacts > 0) {
                        const ratio = blackContacts / whiteContacts;
                        if (ratio > 2.0) { region.forEach(p => { this.territoryMap[p.y][p.x] = 1; }); blackTerritory += region.length; }
                        else if (ratio < 0.5) { region.forEach(p => { this.territoryMap[p.y][p.x] = 2; }); whiteTerritory += region.length; }
                    }
                }
            }
        }
        const blackTotal = blackStones + blackTerritory;
        const whiteTotal = whiteStones + whiteTerritory;
        const diff = blackTotal - whiteTotal;
        let sResult = "æœªçŸ¥";
        if (this.rootNode && this.rootNode.properties['RE']) {
            sResult = this.rootNode.properties['RE'][0];
            if (sResult === 'B+R') sResult = "é»‘ä¸­ç›˜èƒœ"; if (sResult === 'W+R') sResult = "ç™½ä¸­ç›˜èƒœ";
        }
        const content = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div style="background: #f0f0f0; padding: 8px; border-radius: 4px;">
                    <div style="font-weight: bold;">é»‘æ–¹</div>
                    <div style="font-size: 1.1rem;">${blackTotal}</div>
                </div>
                <div style="background: #f0f0f0; padding: 8px; border-radius: 4px;">
                    <div style="font-weight: bold;">ç™½æ–¹</div>
                    <div style="font-size: 1.1rem;">${whiteTotal}</div>
                </div>
            </div>
            <div style="font-size: 1rem; font-weight: bold;">
                ${diff > 0 ? 'é»‘é¢†å…ˆ ' + diff : 'ç™½é¢†å…ˆ ' + Math.abs(diff)}
            </div>
        `;
        document.getElementById('judgeContent').innerHTML = content;
        document.getElementById('judgeModal').style.display = 'flex';
        this.drawBoard();
    }
	
    drawBoard() {
        const ctx = this.ctx;
        const sz = this.boardPixelSize;
        const pad = this.padding;
        const grid = this.gridSize;
        ctx.clearRect(0, 0, sz, sz);

        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.beginPath();
        for (let i = 0; i < this.boardSize; i++) {
            const pos = pad + i * grid;
            ctx.moveTo(pad, pos); ctx.lineTo(sz - pad, pos);
            ctx.moveTo(pos, pad); ctx.lineTo(pos, sz - pad);
        }
        ctx.stroke();

        const stars = [];
        if (this.boardSize === 19) stars.push(3, 9, 15);
        else if (this.boardSize === 13) stars.push(3, 6, 9);
        else if (this.boardSize === 9) stars.push(2, 4, 6);
        if (stars.length > 0) {
            ctx.fillStyle = '#000';
            for (let r of stars) {
                for (let c of stars) {
                    ctx.beginPath(); ctx.arc(pad + c * grid, pad + r * grid, Math.max(2, grid*0.08), 0, Math.PI * 2); ctx.fill();
                }
            }
        }

        if (grid > 15) {
            ctx.fillStyle = '#333'; ctx.font = `${Math.max(8, grid*0.3)}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const letters = 'ABCDEFGHJKLMNOPQRST'.slice(0, this.boardSize);
            for (let i = 0; i < this.boardSize; i++) {
                const pos = pad + i * grid;
                const char = letters[i];
                ctx.fillText(char, pos, pad - 10); ctx.fillText(char, pos, sz - pad + 10);
                ctx.fillText(this.boardSize - i, pad - 10, pos); ctx.fillText(this.boardSize - i, sz - pad + 10, pos);
            }
        }

        for (let y = 0; y < this.boardSize; y++) {
            for (let x = 0; x < this.boardSize; x++) {
                if (this.boardState[y][x] !== 0) this.drawStone(x, y, this.boardState[y][x]);
            }
        }

        if (this.territoryMap) {
            ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            for (let y = 0; y < this.boardSize; y++) {
                for (let x = 0; x < this.boardSize; x++) {
                    const val = this.territoryMap[y][x]; if (val === 0) continue;
                    const cx = pad + x * grid; const cy = pad + y * grid;
                    if (val === 1) { ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.fillText('#', cx, cy); } 
                    else if (val === 2) { 
                        ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2; ctx.strokeText('#', cx, cy);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillText('#', cx, cy);
                    }
                }
            }
        }

        this.drawMarkup();

        if (this.history.length > 1) {
            const currentNode = this.history[this.history.length - 1];
            const props = currentNode.properties;
            let moveCoord = null;
            if (props['B']) moveCoord = this.sgfToCoord(props['B'][0]);
            else if (props['W']) moveCoord = this.sgfToCoord(props['W'][0]);
            if (moveCoord && moveCoord[0] !== -1) {
                const cx = pad + moveCoord[0] * grid; const cy = pad + moveCoord[1] * grid;
                ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2; ctx.beginPath();
                const r = this.stoneRadius * 0.55; 
                ctx.moveTo(cx, cy - r); ctx.lineTo(cx - r * 0.866, cy + r * 0.5); ctx.lineTo(cx + r * 0.866, cy + r * 0.5); ctx.closePath();
                ctx.stroke();
            }
        }
    }

    drawStone(x, y, color) {
        const ctx = this.ctx;
        const cx = this.padding + x * this.gridSize; const cy = this.padding + y * this.gridSize; const r = this.stoneRadius;
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)'; ctx.shadowBlur = 4; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
        if (color === this.engine.BLACK) {
            const grad = ctx.createRadialGradient(cx - r/3, cy - r/3, r/4, cx, cy, r);
            grad.addColorStop(0, '#444'); grad.addColorStop(1, '#000'); ctx.fillStyle = grad;
        } else {
            const grad = ctx.createRadialGradient(cx - r/3, cy - r/3, r/4, cx, cy, r);
            grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#dcdcdc'); ctx.fillStyle = grad;
        }
        ctx.fill(); ctx.shadowColor = 'transparent';
    }

    drawMarkup() {
        if (this.history.length === 0) return;
        const currentNode = this.history[this.history.length - 1];
        const props = currentNode.properties;
        const ctx = this.ctx; const pad = this.padding; const grid = this.gridSize;

        if (props['LB']) {
            ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            props['LB'].forEach(item => {
                const colonIndex = item.indexOf(':'); if (colonIndex === -1) return;
                const coordStr = item.substring(0, colonIndex); const labelText = item.substring(colonIndex + 1);
                const [x, y] = this.sgfToCoord(coordStr); if (x === -1) return;
                const cx = pad + x * grid; const cy = pad + y * grid;
                const bgWidth = Math.max(20, ctx.measureText(labelText).width + 8);
                ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(cx - bgWidth/2, cy - 8, bgWidth, 16);
                ctx.fillStyle = '#e74c3c'; ctx.fillText(labelText, cx, cy);
            });
        }

        const markColor = '#e74c3c'; const markSize = grid * 0.4;
        const drawShapeAt = (coordStr, type) => {
            const [x, y] = this.sgfToCoord(coordStr); if (x === -1) return;
            const cx = pad + x * grid; const cy = pad + y * grid;
            ctx.strokeStyle = markColor; ctx.lineWidth = 2; ctx.beginPath();
            if (type === 'TR') {
                const h = markSize * Math.sqrt(3) / 2;
                ctx.moveTo(cx, cy - markSize); ctx.lineTo(cx - markSize * 0.866, cy + markSize * 0.5); ctx.lineTo(cx + markSize * 0.866, cy + markSize * 0.5); ctx.closePath();
            } else if (type === 'CR') {
                ctx.arc(cx, cy, markSize * 0.8, 0, Math.PI * 2);
            } else if (type === 'SQ') {
                const half = markSize * 0.8; ctx.rect(cx - half, cy - half, half * 2, half * 2);
            } else if (type === 'MA') {
                const half = markSize * 0.6;
                ctx.moveTo(cx - half, cy - half); ctx.lineTo(cx + half, cy + half);
                ctx.moveTo(cx + half, cy - half); ctx.lineTo(cx - half, cy + half);
            }
            ctx.stroke();
        };
        if (props['TR']) props['TR'].forEach(c => drawShapeAt(c, 'TR'));
        if (props['CR']) props['CR'].forEach(c => drawShapeAt(c, 'CR'));
        if (props['SQ']) props['SQ'].forEach(c => drawShapeAt(c, 'SQ'));
        if (props['MA']) props['MA'].forEach(c => drawShapeAt(c, 'MA'));
    }
}

function showToast(msg) {
    const el = document.getElementById('statusMsg');
    el.textContent = msg;
    el.classList.add('show');
    setTimeout(() => el.classList.remove('show'), 2000);
}

document.addEventListener('DOMContentLoaded', () => {
    window.app = new App();
});
</script>
</body>
</html>
